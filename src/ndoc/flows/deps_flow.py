"""
Flow: Dependency Graph Generation.
业务流：生成模块依赖图 (_DEPS.md)。
"""
from pathlib import Path
from typing import Dict, List, Set
from collections import defaultdict

from ..atoms import fs, io, deps
from ..models.config import ProjectConfig

# --- Transformations ---

def collect_imports(root: Path) -> Dict[str, List[str]]:
    """
    Collect imports from all Python files.
    Returns: Dict[RelativePath, List[ImportedModule]]
    """
    import_map = {}
    
    # Only scan .py files
    # Ignore common artifacts
    ignore = {'.git', '__pycache__', 'venv', 'env', 'node_modules', 'dist', 'build', 'site-packages'}
    files = fs.walk_files(root, ignore_patterns=list(ignore), extensions={'.py'})
    
    for file_path in files:
        try:
            content = io.read_text(file_path)
            imports = deps.extract_imports(content)
            
            # Normalize path relative to root
            rel_path = file_path.relative_to(root).as_posix()
            import_map[rel_path] = imports
        except Exception as e:
            print(f"Error parsing {file_path}: {e}")
            
    return import_map

def build_dependency_graph(import_map: Dict[str, List[str]]) -> Dict[str, Set[str]]:
    """
    Build internal dependency graph.
    Matches imports to internal files.
    """
    # Create a map of "possible module names" to file paths
    # e.g. "ndoc/atoms/fs.py" -> "ndoc.atoms.fs"
    
    # We need to guess the module root.
    # If src/ndoc exists, usually 'ndoc' is the root package.
    # For now, we'll try to match "import X" to a file path.
    
    # Simple heuristic:
    # 1. Convert all file paths to dotted notation (removing .py, src/)
    # 2. Check if import matches.
    
    graph = defaultdict(set)
    
    # Helper to convert path to module
    # e.g. src/ndoc/atoms/fs.py -> ndoc.atoms.fs
    path_to_mod = {}
    mod_to_path = {}
    
    for path in import_map.keys():
        # Remove 'src/' prefix if present for module naming
        clean_path = path
        if clean_path.startswith('src/'):
            clean_path = clean_path[4:]
        
        if clean_path.endswith('.py'):
            clean_path = clean_path[:-3]
        elif clean_path.endswith('__init__.py'):
            clean_path = clean_path[:-11] # strip /__init__
            
        module_name = clean_path.replace('/', '.')
        path_to_mod[path] = module_name
        mod_to_path[module_name] = path

    for file_path, imports in import_map.items():
        source_mod = path_to_mod.get(file_path)
        if not source_mod:
            continue
            
        for imp in imports:
            # Check if 'imp' is one of our internal modules
            # Exact match
            if imp in mod_to_path:
                graph[source_mod].add(imp)
                continue
            
            # Parent match (e.g. import ndoc.atoms -> ndoc.atoms.fs ?) 
            # Usually we import specific modules.
            
            # Check sub-modules (e.g. from ndoc import atoms -> ndoc.atoms)
            # This is hard without full resolution.
            # Let's stick to simple prefix matching for now.
            
            # If import starts with project root package?
            # We assume the first part of the module name is the package.
            root_pkg = source_mod.split('.')[0]
            if imp.startswith(root_pkg):
                 # It's likely internal, but maybe we didn't scan it (e.g. generated?)
                 pass

    return graph

def generate_mermaid_graph(graph: Dict[str, Set[str]]) -> str:
    """Generate Mermaid flowchart"""
    lines = ["graph TD"]
    
    # Sort for stability
    for source in sorted(graph.keys()):
        targets = sorted(list(graph[source]))
        for target in targets:
            # Avoid self-loops
            if source == target:
                continue
            lines.append(f"    {source} --> {target}")
            
    if len(lines) == 1:
        return "*No internal dependencies detected.*"
        
    return "```mermaid\n" + "\n".join(lines) + "\n```"

def run(config: ProjectConfig) -> bool:
    """Execute the Deps Flow"""
    target_file = config.scan.root_path / "_DEPS.md"
    
    print(f"Scanning dependencies in {config.scan.root_path}...")
    import_map = collect_imports(config.scan.root_path)
    
    graph = build_dependency_graph(import_map)
    mermaid = generate_mermaid_graph(graph)
    
    content = f"""# Dependency Graph

> Auto-generated by Niki-docAI.

## Module Graph (Internal)

{mermaid}

> **Note**: Detailed per-file dependencies (Raw Imports) have been moved to local `_AI.md` files to keep this view clean.
"""
    
    io.write_text(target_file, content)
    return True
